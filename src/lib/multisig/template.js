/**
 * Util function for grouping every possible cosigner combinations.
 *
 * @param {Object} params
 * @param {number} params.m - The number of cosigners to select
 * @param {number} params.n - The total number of cosigners
 * @returns {number[][]} - An array of arrays, each containing a combination of cosigners
 * 
 * Example usage:
 * const m = 2 Cosigners to select
 * const n = 3 Total cosigners
 * const combinations = groupCosigners({m, n})
 * // Output:
 * [
 *  [1, 2],
 *  [1, 3],
 *  [2, 3]
 * ]
 */
export const groupCosigners = ({ m, n }) /*: str[][] */ => {
  const result = []

  const combine = (start, currentCombination) => {
    // If the current combination has m elements, add it to the result
    if (currentCombination.length === m) {
      result.push([...currentCombination])
      return
    }

    // Iterate over the remaining elements to form combinations
    for (let i = start; i <= n; i++) {
      currentCombination.push(i)
      combine(i + 1, currentCombination)
      currentCombination.pop()
    }
  }

  combine(1, [])
  return result
}

/**
 * Generate checkbits required for schnorr signatures.
 * @param {number[]} cosignerGroups - An array of cosigner positions (1-indexed)
 * @returns {string} - A string representing the checkbits, e.g: `<0b1010>` for schnorr
 */
export const generateSchnorrCheckbits = (cosignerGroups) => {
  let checkbit = 0
  for (const cosignerPosition of cosignerGroups) {
    checkbit = checkbit | (1 << cosignerPosition - 1)
  }
  return `<0b${checkbit.toString(2).padStart(3, '0')}>`
}

/**
 * @param {Object} params
 * @param {number[]} params.cosignerGroup - An array of cosigner positions (1-indexed), e.g. [2, 3]
 * @param {SignatureAlgorithm} [params.signatureAlgorithm='schnorr'] - The signature algorithm to use
 * @returns {string} - A string representing unlocking script dummy, e.g: `<0b1010>` for schnorr or OP_0 for ecdsa
 */
export const generateUnlockingScriptDummy = ({
  cosignerGroup /* : int[] // example: [2, 4] */,
  signatureAlgorithm /* ?: ecdsa | schnorr */
}) => {
  const dummy = 'OP_0' // ecdsa
  if (signatureAlgorithm === 'schnorr') {
    return generateSchnorrCheckbits(cosignerGroup)
  }

  return dummy
}

/**
 * 
 * @param {Object} params
 * @param {number} params.m - The required number of signatures
 * @param {number} params.n - The total number of signers
 * @returns {Object} - An object representing the locking script
 */
export const generateLockScript = ({ m, n }) => {
  let script = `OP_${m}\n<pubkeys>OP_${n}\nOP_CHECKMULTISIG`
  let pubkeys = ''
  for (let i = 1; i < n + 1; i++) {
    pubkeys += `<key${i}.public_key>\n`
  }
  script = script.replace('<pubkeys>', pubkeys)
  return {
    lockingType: 'p2sh20',
    name: `${m} of ${n} Vault`,
    script
  }
}

/**
 * @param {Object} params
 * @param {number} params.m - The required number of signatures
 * @param {number} params.n - The total number of signers
 * @param {SignatureAlgorithm} params.signatureAlgorithm
 */
export const generateScripts = ({ m, n, signatureAlgorithm}) => {
  const cosignerGroups = groupCosigners({ m, n })
  const scripts = {}

  for (const cosignerGroup of cosignerGroups) {
    const key = cosignerGroup.join('_and_')
    const name = `Cosigner ${cosignerGroup.join(' & ')}`
    const dummy = generateUnlockingScriptDummy({ cosignerGroup, signatureAlgorithm })
    let script = dummy
    for (const cosignerPosition of cosignerGroup) {
      script += `\n<key${cosignerPosition}.${signatureAlgorithm}_signature.all_outputs>`
    }
    scripts[key] = {
      name,
      script,
      unlocks: 'lock'
    }
  }
  scripts.lock = generateLockScript({ m, n })
  return scripts
}

/**
 * @param {Object} params
 * @param {number} params.signerIndex - The signer's position on the unlocking script, starts at 1
 * @param {Object} params.scripts - The scripts object generated by generateScripts()
 * @param {MultisigWalletSigner} params.signer - The signer object containing with `publicKey` and `name`
 */
export const generateEntity = ({
  signerIndex,
  scripts,
  signer
}) /* :BitauthTemplateEntity */ => {
  let signerScriptNames = Object.entries(scripts)
    .filter(([scriptName] /* ,scriptValue */) => {
      return scriptName.includes(signerIndex)
    })
    .map(([scriptName]) => {
      return scriptName
    })

  // include 'lock'
  signerScriptNames = ['lock', ...signerScriptNames]
  const entityKey = `signer_${signerIndex}`
  const entityValue = {
    description: '',
    name: signer.name || `Signer ${signerIndex}`,
    scripts: signerScriptNames,
    variables: {
      [`key${signerIndex}`]: {
        description: '',
        name: `key${signerIndex}`,
        type: 'Key'
      }
    }
  }
  return [entityKey, entityValue]
}

/**
 * @param {number} n - Total number of signers
 * @param {MultisigWalletSigner[]} signers - Array of signer objects with `name` and `xpub` and `publicKey` properties
 * @returns {import('bitauth-libauth-v3').BitauthTemplateEntity}
 */
export const generateEntities = ({ n, scripts, signers }) => {
  const entities = {}
  for (let i = 0; i < n; i++) {
    const [entityKey, entityValue] = generateEntity({ signerIndex: i + 1, scripts, signer: signers[i] })
    entities[entityKey] = entityValue
  }
  return entities
}

/**
 * @param {TemplateCreatorParams} params
 */
export const createTemplate = ({
  m,
  signers,
  signatureAlgorithm = 'schnorr',
  name,
  $schema = 'https://libauth.org/schemas/wallet-template-v0.schema.json',
  supported = ['BCH_2021_05', 'BCH_2022_05', 'BCH_2023_05']
}) => {
  const n = signers.length
  const template = {
    name: name || `${m}-of-${n} Multisig`,
    $schema,
    entities: { /* generate */ },
    scripts: { /* generate */ },
    supported,
    version: 0
  }
  template.scripts = generateScripts({ m, n, signatureAlgorithm })
  template.entities = generateEntities({ n, scripts: template.scripts, signers })
  return template
}
