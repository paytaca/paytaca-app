import { compileString } from 'cashc0.11.x';
import source from './contract/TapToPay-app.cash';
const artifact = compileString(source);
import {Contract, ElectrumNetworkProvider, TransactionBuilder} from 'cashscript';
import crypto from 'crypto';

export class TapToPay {
	
    // build the contructor arguments here: ownerPkh, backendPkh, category, BCV
    constructor(ownerPkh, backendPkh, category, BCV){
        this.ownerPkh = ownerPkh
        this.backendPkh = backendPkh
        this.category = category
        this.BCV = BCV  
    }
   

    // create a new Tap to Pay contract
    async createContract(ownerPkh, backendPkh, category){
        const newBCV = this.generateBCV()
        const args = [ownerPkh, backendPkh, category, newBCV]
        const provider = new ElectrumNetworkProvider('mainnet')
        const options = {provider, addressType: 'p2sh32'}
        const contract = new Contract(artifact, args, options)
        console.log("New Tap to Pay contract created:")
        return contract
    }

    /**
     * There should be a backend computed value (BCV) for each transaction to prevent replay attacks.
     * The merchant should not understand the BCV, it is just a random number generated by the backend.
     * Contract needs to be aware of the new BCV for each transaction.
     * --- Mutation ---
     * @returns newBCV
     */
    generateBCV(){
        let newBCV = crypto.randomBytes(16).toString('hex')
        return newBCV
    }

    getConstructorArgs(){
        return [this.ownerPkh, this.backendPkh, this.category, this.BCV]
    }
    
    /**
     * spend from the contract needs backend signature - added security on top of BCV
     * the ownerPrivateKeyWIF is needed to sign the transaction
     * The paytaca POS app (acting as terminal) will request the backend to sign the transaction
     * The POS reads and writes data on the NFC card (acting as a wallet)
     * Granting is just sending a copy of auth NFT to the contract
     * Somewhere in the auth commitment - there should be a flag that indicated if merchant is authorized to receive payments
     * If not authorized, the auth NFT for that merchant will be burned
     * 1 merchant = 1 auth NFT
     * @param {*} contract - the Tap to Pay contract instance
     * @param {*} toAddress - toAddress is the recipient address
     * @param {*} amountSatoshis - amount in satoshis to send
     * @param {*} ownerPrivateKeyWIF - owner's private key in WIF format
     * @param {*} authNFT - if the merchant doesn't have an auth NFT, the transaction will be rejected
     * @returns transaction hex
     */
    async spendContract(contract, toAddress, amountSatoshis, ownerPrivateKeyWIF, authNFT){
        // check if authNFT is valid - placeholder for actual implementation
        if(!authNFT || authNFT.length === 0){
            throw new Error("Invalid auth NFT. Merchant not authorized.")
        }

        const tx = new TransactionBuilder()
        tx.addOutput(toAddress, amountSatoshis)
        const {transaction, fee, change} = await contract.functions.spend(
            tx,
            amountSatoshis,
            authNFT,
            ownerPrivateKeyWIF
        )
        console.log(`Transaction created. Fee: ${fee} satoshis, Change: ${change} satoshis`)
        return transaction.toHex()

        // backend (server) should sign the transaction if it is valid
        // backend - backendWif, backendSig, backendPk, backendPkh
        if(backendPkh !== contract.getConstructorArgs()[1]){
            throw new Error("Backend PKH does not match contract backend PKH.")
        }

        // terminal (POS app) should sign the transaction if it is valid
        // terminal - terminalWif, terminalSig, terminalPk

    }
    // get contract info: address, balance, UTXOs
    async getContractInfo(contract){
      const info = {
        address: contract.address,
        balance: await this.getContractBalance(contract),
        utxos: await this.getUtxos(contract)
      }
      return info
    }

    



}








