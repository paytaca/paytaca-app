import { compileString } from 'cashc0.11.x';
import source from './contract/TapToPay-app.cash';
const artifact = compileString(source);
import {Contract, ElectrumNetworkProvider, TransactionBuilder, SignatureTemplate, script} from 'cashscript';
import crypto, { sign } from 'crypto';

/**
 * --- UTILITY FUNCTIONS ---
 * Simulation: Decodes the commitment data from the Auth NFT
 * Structure: [auth flag (1)] + [expiration block (4)] + [spendLimit (8)] + [expectedTerminalHash (20)]
 * @param {Buffer} commitment - The raw commitment buffer from the auth NFT
 * @returns {object} Decoded commitment fields
 */
function decodeCommitment(commitment){
    // buffer.slice() is deprecated
    // Note: to include BCV here, which must be encoded into the commitment
    // for the contract to validate its rotation
    // Assuming, new structure:
    // [auth flag(1)] + [expirationBlock(4)] + [spendLimit(4)] + [currentBCV(11)] + [expectedTerminalHash(20)]

    let offset = 0

    const flag = commitment.subarray(offset, offset + 1)
    offset += 1

    const expirationBlock = commitment.subarray(offset, offset + 4)
    offset += 4

    const spendLimit = commitment.subarray(offset, offset + 4)
    offset += 4

    // assuming BCV is 16 bytes after spendLimit
    const currentBCV = commitment.subarray(offset, offset + 11)
    offset += 11

    const expectedTerminalHash = commitment.subarray(offset, offset + 20)
    offset += 20

    // convert to usable types
    return {
        flag: flag.toString('hex'),
        expirationBlock: parseInt(expirationBlock.toString('hex'), 16),
        spendLimit: BigInt('0x' + spendLimit.toString('hex')), // for full 64-bit precision
        currentBCV: currentBCV.toString('hex'),
        expectedTerminalHash: expectedTerminalHash.toString('hex')
    }
}

/**
 * Simulation: Encodes the next state of the commitment data for the Auth NFT
 * Rotating thre BCV for the next tap
 * @param {object} fields - The commitment fields to encode, including the newBCV
 * @returns {Buffer} The new commitment buffer
 */
function encodeNewCommitment(fields, newBCVBuffer){
    // Re-encode everything, replacing the currentBCV with the newBCV
    const flag = Buffer.from(fields.flag, 'hex')
    const expirationBlock = Buffer.from(fields.expirationBlock.toString(16).padStart(8, '0'), 'hex')
    const spendLimit = Buffer.from(fields.spendLimit.toString(16).padStart(8, '0'), 'hex')
    const expectedTerminalHash = Buffer.from(fields.expectedTerminalHash, 'hex')

    // Assemble the new commitment buffer with the newly generated BCV
    const newCommitment = Buffer.concat([
        flag, 
        expirationBlock,
        spendLimit, 
        newBCVBuffer,
        expectedTerminalHash
    ])
    return newCommitment
}


export class TapToPay {
	
    // build the contructor arguments here: ownerPkh, backendPkh, category, BCV
    constructor(ownerPkh, backendPkh, category, currentBCV){
        this.ownerPkh = ownerPkh
        this.backendPkh = backendPkh
        this.category = category
        this.currentBCV = currentBCV  // The current BCV expected by the contract state
        this.provider = new ElectrumNetworkProvider('mainnet') // setting provider once
    }
   
    // createContract requires the initial BCV
    async createContract(ownerPkh, backendPkh, category){
        const initialBCV = this.generateBCV() // generate the first BCV

        const args = [ownerPkh, backendPkh, category, initialBCV]
        const options = {provider: this.provider, addressType: 'p2sh32'}
        const contract = new Contract(artifact, args, options)
        console.log(`New Tap to Pay contract created at: ${contract.address} with initial BCV: ${initialBCV.toString('hex')}`)
        this.currentBCV = initialBCV
        return contract
    }

    /**
     * Generates a new random 16-byte BCV (Backend Computed Value)
     * for each transaction to prevent replay attacks.
     * The merchant should not understand the BCV, it is just a random number generated by the backend.
     * Contract needs to be aware of the new BCV for each transaction.
     * @returns {Buffer} newBCV as a Buffer
     */
    generateBCV(){
        return crypto.randomBytes(11)
    }

    getConstructorArgs(){
        return [this.ownerPkh, this.backendPkh, this.category, this.currentBCV]
    }
    
    /**
     * CORE FUNCTION: Executes the TapToPay spend operation
     * This function must handle input/output building, BCV rotationm, and dual signing
     * @param {Contract} contract - The TapToPay contract instance
     * @param {UTXO[]} fundingUtxos - Regular BCH UTXOs to cover transaction fee and change
     * @param {UTXO} authNftUtxo - The Auth NFT UTXO to be consumed as the first input 
     * @param {string} recipientPkh - The PKH of the merchant's wallet to receive payment 
     * @param {number} amountSatoshis - Amount in satoshis to send 
     * @param {Buffer} terminalPk - The public key of the Paytaca POS app (terminal)
     * @param {Buffer} terminalId - The unique ID of the Paytaca POS app
     * @param {SignatureTemplate} terminalSigTemplate - Template for the terminal's signature
     * @param {Buffer} backendPk - The public key of the Paytaca backend server
     * @param {SignatureTemplate} backendSigTemplate - Template for the backend's signature
     * @returns {string} transaction hex
     */
    async spendContract(
        contract,
        fundingUtxos,
        authNftUtxo,
        recipientPkh,
        amountSatoshis,
        terminalPk,
        terminalId,
        terminalSigTemplate,
        backendPk,
        backendSigTemplate
    ){
        // Validate the currentBCV against the commitment
        const commitmentData = Buffer.from(authNftUtxo.nft.commitment, 'hex')
        const decodedState = decodeCommitment(commitmentData)

        // Ensure the Auth NFT's current BCV matches the contract's expected BCV
        if(decodedState.currentBCV !== this.currentBCV.toString('hex')){
            throw new Error(`BCV Mismatch: Auth NFT has ${decodedState.currentBCV}, but contract expects: ${this.currentBCV.toString('hex')}. Replay attempt or out-of-sync state.`)
        }

        // Generate the new BCV for the next state
        const newBCVBuffer = this.generateBCV()
        const newCommitment = encodeNewCommitment(decodedState, newBCVBuffer)

        // Auth NFT must be sent back to the contract's address with the updated commitment
        const authNftReturnOutput = {
            // Must return the exact NFT
            cash: contract.address,
            value: authNftUtxo.satoshis,
            // The Auth NFT token ID (category + commitment) must be preserved
            token: {
                category: authNftUtxo.nft.category,
                nft: {
                    capability: 'none',
                    commitment: newCommitment.toString('hex') // new BCV commitment
                }
            }
        }

        // Prepare the Payment Output (Output[1])
        const paymentOutput = {
            // Note: recipientPkh should be hash160(terminalPk) for the P2PKH lock
            cash: script.p2pkh.lockingScript(recipientPkh),
            value: amountSatoshis
        }

        // Build the transaction
        // Following the contract's spend function parameter order
        const txBuilder = contract.functions.spend(
            terminalId,
            terminalSigTemplate,
            terminalPk,
            backendSigTemplate,
            backendPk
        )

        // Auth NFT UTXO as the first input
        txBuilder.from(authNftUtxo)
        // Add funding UTXOs (regular BCH) for fees/change
        txBuilder.from(fundingUtxos)

        // Output[0]: Auth NFT return with new commitment
        txBuilder.to(authNftReturnOutput)
        // Output[1]: Payment to the merchant
        txBuilder.to(paymentOutput)
        // Output[2]: Change (handled automatically by CashScript/TransactionBuilder)

        // Sign and Send the transaction
        const {transaction: signedTx, change} = await txBuilder.send()

        // Success: Update the contract's state locally with the new BCV
        this.currentBCV = newBCVBuffer

        console.log(`Transaction successful. Fee: ${signedTx.fee} satoshis, Change: ${change} satoshis`)
        console.log(`New BCV successfully rotated to: ${newBCVBuffer.toString('hex')}`)

        return signedTx.toHex()
    }

    /**
     * Owner Function: Allows the contract owner to drain all funds from the contract
     * @param {Contract} contract - The TapToPay contract instance
     * @param {string} ownerPrivateKeyWif - The owner's private key in WIF format
     * @param {string} recipientAddress - The address to send the swept funds to
     * @returns {string} transaction hex
     */
    async sweepFunds(contract, ownerPrivateKeyWif, recipientAddress){
        // Set up signature template for the owner
        const ownerSignature = new SignatureTemplate(ownerPrivateKeyWif)
        // Get the owner's public key
        const ownerPk = ownerSignature.getPublicKey()

        // Define the recipient output
        const recipientLock = script.p2pkh.lockingScript(recipientAddress)

        // Call the sweep function (takes all utxos, sends to one output)
        const txBuilder = contract.functions.sweep(ownerPk, ownerSignature)

        // Calculate total funds (excluding fees) and send it to the recipient
        txBuilder.to(recipientLock, txBuilder.getInputs().reduce((acc, input) => acc + input.satoshis, 0)) // send all funds

        const {transaction: signedTx} = await txBuilder.send()
        console.log(`Sweep transaction successful. Funds sent to: ${recipientAddress}`)
        return signedTx.toHex()
    }

    /**
     * Owner Function: Mutates the contract's state, specifically to update the BCV variable
     * This is useful for rotating the BCV if a card is lost/stolen, or for system maintenance
     * @param {Contract} contract - The TapToPay contract instance
     * @param {string} ownerPrivateKeyWif - The owner's private key in WIF format 
     * @param {Buffer} newBCV - The new BCV to hardcode into the contrct's state
     * @returns {string} transaction hex
     */
    async mutateContract(contract, ownerPrivateKeyWif, newBCV){
        // Set up signature template for the owner
        const ownerSignature = new SignatureTemplate(ownerPrivateKeyWif)
        const ownerPk = ownerSignature.getPublicKey()

        // Create the new contract instance with the updated BCV
        const [ownerPkh, backendPkh, category] = this.getConstructorArgs()
        const newArgs = [ownerPkh, backendPkh, category, newBCV]
        const newContract = new Contract(artifact, newArgs, {
            provider: this.provider,
            addressType: 'p2sh32'
        })

        // Call the mutate function
        // The mutation function requires the owner's signature and the bytecode of the new contract
        const txBuilder = contract.functions.mutate(ownerPk, ownerSignature)

        // Mutate must send all current funds to the new contract address
        txBuilder.to(newContract.address, txBuilder.getInputs().reduce((acc, input) => acc + input.satoshis, 0))

        const {transaction: signedTx} = await txBuilder.send()

        // Update the local state of the class
        this.currentBCV = newBCV

        console.log(`Contract successfully mutated. New contract address: ${newContract.address}`)
        console.log(`New BCV successfully hardcoded in contract state to: ${newBCV.toString('hex')}`)

        return signedTx.toHex()
    }

    // get contract info: address, balance, UTXOs
    async getContractInfo(contract){
      const info = {
        address: contract.address,
        balance: await this.getContractBalance(contract),
        utxos: await this.getUtxos(contract)
      }
      return info
    }

    async getContractBalance(contract){
        const balance = await this.provider.getContractBalance(contract.address)
        return balance
    }

    async getUtxos(contract){
        const utxos = await this.provider.getUtxos(contract.address)
        return utxos
    }

}








