pragma cashscript ^0.12.0;

contract TapToPay(bytes20 ownerPkh, bytes20 backendPkh, bytes category) {

    function spend(
        bytes merchantId, 
        sig merchantSig, 
        pubkey merchantPk, 
        sig backendSig, 
        pubkey backendPk) {
        
        require(hash160(backendPk) == backendPkh, 'Invalid backend public key hash');
        require(checkSig(backendSig, backendPk), 'Invalid backend signature');
        require(checkSig(merchantSig, merchantPk), 'Invalid merchant signature');

        // enforcing that the min number of outputs is 2 and max is 3
        require(tx.outputs.length >= 2 && tx.outputs.length <= 3, 'Unexpected number of outputs, must be 2 or 3');

        // verifies that the token category of the input NFT matches the expected category
        bytes tokenCategory = (tx.inputs[0].tokenCategory).split(32)[0]; 
        require(tokenCategory == category, 'Invalid token category'); 

        bytes commitment = tx.inputs[0].nftCommitment;

        // obtains the authFlag from the commitment (authFlag is 1 byte)
        bytes authFlag, bytes rest = commitment.split(1);

        // obtains the expirationBlock from the rest of the commitment (next 4 bytes)
        bytes expirationBlock, bytes rest2 = rest.split(4);

        // obtains the spendLimit from the rest of the commitment (next 8 bytes), 
        // the rest of the remaining bytes is the expectedMerchantHash
        bytes spendLimit, bytes expectedMerchantHash = rest2.split(8);
        
        // checks if payment is enabled
        require(authFlag == 0x01, 'Access denied: Merchant is not authorized');

        // verify that the parameter merchantHash matches expectedMerchantHash from the commitment
        bytes fullHash = sha256(merchantId + merchantPk);
        bytes merchantHash = fullHash.split(27)[0];
        require(merchantHash == expectedMerchantHash, 'Access denied: Invalid merchant id');

        // require that the auth NFT is not expired
        require(tx.locktime <= int(expirationBlock), 'Authentication has expired');

        // require that auth NFT commitment is not tampered with after spending
        require(commitment == tx.outputs[0].nftCommitment, 'Auth NFT output commitment should not change');

        // require that auth NFT is sent back to this contract
        bytes contractLock = tx.inputs[this.activeInputIndex].lockingBytecode;
        bool nftSendsToContract = tx.outputs[0].lockingBytecode == contractLock;
        require(nftSendsToContract, 'Auth NFT must send back to this contract');

        // require that the send amount is sent to the recipient (merchant)
        bytes25 recipientLock = new LockingBytecodeP2PKH(hash160(merchantPk));
        bool sendsToRecipient = tx.outputs[1].lockingBytecode == recipientLock;
        require(sendsToRecipient, 'Send amount must send to the recipient');

        // check that send amount is correct
        int actualSendAmount = tx.outputs[1].value;
        require(actualSendAmount <= int(spendLimit), 'Send amount exceeds spend limit');

        // require that any change (enforced to be at output[2]) is sent back to this contract
        if (tx.outputs.length == 3) {
            require(tx.outputs[2].lockingBytecode == contractLock, 'Change must be sent back to contract');
        }
    
    }

    function sweep(pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');
    }

    function mutate (pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');
    }
}