{
  "contractName": "TapToPay",
  "constructorInputs": [
    {
      "name": "ownerPkh",
      "type": "bytes20"
    },
    {
      "name": "backendPkh",
      "type": "bytes20"
    },
    {
      "name": "category",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "spend",
      "inputs": [
        {
          "name": "merchantId",
          "type": "bytes"
        },
        {
          "name": "merchantSig",
          "type": "sig"
        },
        {
          "name": "merchantPk",
          "type": "pubkey"
        },
        {
          "name": "backendSig",
          "type": "sig"
        },
        {
          "name": "backendPk",
          "type": "pubkey"
        }
      ]
    },
    {
      "name": "sweep",
      "inputs": [
        {
          "name": "ownerPk",
          "type": "pubkey"
        },
        {
          "name": "ownerSig",
          "type": "sig"
        }
      ]
    },
    {
      "name": "mutate",
      "inputs": [
        {
          "name": "ownerPk",
          "type": "pubkey"
        },
        {
          "name": "ownerSig",
          "type": "sig"
        }
      ]
    }
  ],
  "bytecode": "OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_8 OP_PICK OP_HASH160 OP_ROT OP_EQUALVERIFY OP_6 OP_ROLL OP_7 OP_ROLL OP_CHECKSIGVERIFY OP_4 OP_ROLL OP_5 OP_PICK OP_CHECKSIGVERIFY OP_TXOUTPUTCOUNT OP_2 OP_GREATERTHANOREQUAL OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_BOOLAND OP_VERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_ROT OP_EQUALVERIFY OP_0 OP_UTXOTOKENCOMMITMENT OP_DUP OP_1 OP_SPLIT OP_4 OP_SPLIT OP_8 OP_SPLIT OP_3 OP_ROLL OP_1 OP_EQUALVERIFY OP_6 OP_ROLL OP_7 OP_PICK OP_CAT OP_SHA256 1b OP_SPLIT OP_DROP OP_EQUALVERIFY OP_TXLOCKTIME OP_ROT OP_BIN2NUM OP_LESSTHANOREQUAL OP_VERIFY OP_SWAP OP_0 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY 76a914 OP_5 OP_ROLL OP_HASH160 OP_CAT 88ac OP_CAT OP_1 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_1 OP_OUTPUTVALUE OP_ROT OP_BIN2NUM OP_LESSTHANOREQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF OP_2 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_ENDIF OP_2DROP OP_DROP OP_1 OP_ELSE OP_3 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_4 OP_PICK OP_HASH160 OP_EQUALVERIFY OP_4 OP_ROLL OP_4 OP_ROLL OP_CHECKSIG OP_NIP OP_NIP OP_NIP OP_ELSE OP_3 OP_ROLL OP_2 OP_NUMEQUALVERIFY OP_3 OP_PICK OP_HASH160 OP_EQUALVERIFY OP_2SWAP OP_CHECKSIG OP_NIP OP_NIP OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.11.0;\n\ncontract TapToPay(bytes20 ownerPkh, bytes20 backendPkh, bytes category) {\n\n    function spend(\n        bytes merchantId, \n        sig merchantSig, \n        pubkey merchantPk, \n        sig backendSig, \n        pubkey backendPk) {\n        \n        require(hash160(backendPk) == backendPkh, 'Invalid backend public key hash');\n        require(checkSig(backendSig, backendPk), 'Invalid backend signature');\n        require(checkSig(merchantSig, merchantPk), 'Invalid merchant signature');\n\n        // enforcing that the min number of outputs is 2 and max is 3\n        require(tx.outputs.length >= 2 && tx.outputs.length <= 3, 'Unexpected number of outputs, must be 2 or 3');\n\n        // verifies that the token category of the input NFT matches the expected category\n        bytes tokenCategory = (tx.inputs[0].tokenCategory).split(32)[0]; \n        require(tokenCategory == category, 'Invalid token category'); \n\n        bytes commitment = tx.inputs[0].nftCommitment;\n\n        // obtains the authFlag from the commitment (authFlag is 1 byte)\n        bytes authFlag, bytes rest = commitment.split(1);\n\n        // obtains the expirationBlock from the rest of the commitment (next 4 bytes)\n        bytes expirationBlock, bytes rest2 = rest.split(4);\n\n        // obtains the spendLimit from the rest of the commitment (next 8 bytes), \n        // the rest of the remaining bytes is the expectedMerchantHash\n        bytes spendLimit, bytes expectedMerchantHash = rest2.split(8);\n        \n        // checks if payment is enabled\n        require(authFlag == 0x01, 'Access denied: Merchant is not authorized');\n\n        // verify that the parameter merchantHash matches expectedMerchantHash from the commitment\n        bytes fullHash = sha256(merchantId + merchantPk);\n        bytes merchantHash = fullHash.split(27)[0];\n        require(merchantHash == expectedMerchantHash, 'Access denied: Invalid merchant id');\n\n        // require that the auth NFT is not expired\n        require(tx.locktime <= int(expirationBlock), 'Authentication has expired');\n\n        // require that auth NFT commitment is not tampered with after spending\n        require(commitment == tx.outputs[0].nftCommitment, 'Auth NFT output commitment should not change');\n\n        // require that auth NFT is sent back to this contract\n        bytes contractLock = tx.inputs[this.activeInputIndex].lockingBytecode;\n        bool nftSendsToContract = tx.outputs[0].lockingBytecode == contractLock;\n        require(nftSendsToContract, 'Auth NFT must send back to this contract');\n\n        // require that the send amount is sent to the recipient (merchant)\n        bytes25 recipientLock = new LockingBytecodeP2PKH(hash160(merchantPk));\n        bool sendsToRecipient = tx.outputs[1].lockingBytecode == recipientLock;\n        require(sendsToRecipient, 'Send amount must send to the recipient');\n\n        // check that send amount is correct\n        int actualSendAmount = tx.outputs[1].value;\n        require(actualSendAmount <= int(spendLimit), 'Send amount exceeds spend limit');\n\n        // require that any change (enforced to be at output[2]) is sent back to this contract\n        if (tx.outputs.length == 3) {\n            require(tx.outputs[2].lockingBytecode == contractLock, 'Change must be sent back to contract');\n        }\n    \n    }\n\n    function sweep(pubkey ownerPk, sig ownerSig) {\n        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');\n        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');\n    }\n\n    function mutate (pubkey ownerPk, sig ownerSig) {\n        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');\n        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');\n    }\n}",
  "debug": {
    "bytecode": "5379009c635879a97b88567a577aad547a5579adc452a2c453a19a6900ce01207f757b8800cf76517f547f587f537a5188567a57797ea8011b7f7588c57b81a1697c00d288c0c700cd78880376a914557aa97e0288ac7e51cd8851cc7b81a169c4539c6352cd7888686d7551675379519c635479a988547a547aac77777767537a529d5379a98872ac77776868",
    "sourceMap": "5:4:68:5;;;;;12:24:12:33;;:16::34:1;:38::48:0;:8::85:1;13:25:13:35:0;;:37::46;;:8::78:1;14:25:14:36:0;;:38::48;;:8::81:1;17:16:17:33:0;:37::38;:16:::1;:42::59:0;:63::64;:42:::1;:16;:8::114;20:41:20:42:0;:31::57:1;:65::67:0;:30::68:1;:::71;21:33:21:41:0;:8::69:1;23:37:23:38:0;:27::53:1;26:37:26:47:0;:54::55;:37::56:1;29:56:29:57:0;:45::58:1;33:67:33:68:0;:55::69:1;36:16:36:24:0;;:28::32;:8::79:1;39:32:39:42:0;;:45::55;;:32:::1;:25::56;40:44:40:46:0;:29::47:1;:::50;41:8:41:92;44:16:44:27:0;:35::50;:31::51:1;:16;:8::83;47:16:47:26:0;:41::42;:30::57:1;:8::107;50:39:50:60:0;:29::77:1;51:45:51:46:0;:34::63:1;:67::79:0;:34:52:80:1;55:32:55:77:0;:65::75;;:57::76:1;:32::77;;;56:43:56:44:0;:32::61:1;::57:76;60:42:60:43:0;:31::50:1;61:40:61::0;:36::51:1;:16;:8::88;64:12:64:29:0;:33::34;:12:::1;:36:66:9:0;65:31:65:32;:20::49:1;:53::65:0;:12::107:1;64:36:66:9;5:4:68:5;;;;70::73::0;;;;;71:24:71:31;;:16::32:1;:8::79;72:25:72:33:0;;:35::42;;:8::72:1;70:4:73:5;;;;75::78::0;;;;76:24:76:31;;:16::32:1;:8::79;77:25:77:42:0;:8::72:1;75:4:78:5;;3:0:79:1;",
    "logs": [],
    "requires": [
      {
        "ip": 12,
        "line": 12,
        "message": "Invalid backend public key hash"
      },
      {
        "ip": 17,
        "line": 13,
        "message": "Invalid backend signature"
      },
      {
        "ip": 22,
        "line": 14,
        "message": "Invalid merchant signature"
      },
      {
        "ip": 30,
        "line": 17,
        "message": "Unexpected number of outputs, must be 2 or 3"
      },
      {
        "ip": 37,
        "line": 21,
        "message": "Invalid token category"
      },
      {
        "ip": 50,
        "line": 36,
        "message": "Access denied: Merchant is not authorized"
      },
      {
        "ip": 60,
        "line": 41,
        "message": "Access denied: Invalid merchant id"
      },
      {
        "ip": 65,
        "line": 44,
        "message": "Authentication has expired"
      },
      {
        "ip": 69,
        "line": 47,
        "message": "Auth NFT output commitment should not change"
      },
      {
        "ip": 75,
        "line": 52,
        "message": "Auth NFT must send back to this contract"
      },
      {
        "ip": 85,
        "line": 57,
        "message": "Send amount must send to the recipient"
      },
      {
        "ip": 91,
        "line": 61,
        "message": "Send amount exceeds spend limit"
      },
      {
        "ip": 99,
        "line": 65,
        "message": "Change must be sent back to contract"
      },
      {
        "ip": 113,
        "line": 71,
        "message": "Invalid owner public key hash"
      },
      {
        "ip": 119,
        "line": 72,
        "message": "Invalid owner signature"
      },
      {
        "ip": 130,
        "line": 76,
        "message": "Invalid owner public key hash"
      },
      {
        "ip": 133,
        "line": 77,
        "message": "Invalid owner signature"
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.4"
  },
  "updatedAt": "2026-01-13T03:46:11.665Z"
}