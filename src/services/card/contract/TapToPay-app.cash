pragma cashscript ^0.11.0;

contract TapToPay(
  bytes20 ownerPkh, 
  bytes20 backendPkh, 
  bytes category,
  bytes currentBCV
  ) {

    /** terminalId and terminalPk now refer to POS app */
    function spend(
      bytes TerminalId,
      sig terminalSig, 
      pubkey terminalPk, 
      sig backendSig, 
      pubkey backendPk 
    ){
      // --- Signature verifications ---
      require(hash160(backendPk) == backendPkh, 'Invalid backend public key hash');
      require(checkSig(backendSig, backendPk), 'Invalid backend signature');
      require(checkSig(terminalSig, terminalPk), 'Invalid app (terminal) signature');

      // must have min 2 and max 3 outputs only
       require(tx.outputs.length >= 2 && tx.outputs.length <= 3, 'Unexpected number of outputs');
      
      /*
        Auth NFT presented must have correct category
        Take the first 32 bytes (base tokenID) of the token category from the first input and save it as tokenCategory.
        Specified 32 bytes just in case it's longer (e.g. 64 bytes) - the rest of the bytes may just be commitment data
      */
      bytes tokenCategory = (tx.inputs[0].tokenCategory).split(32)[0];
      require(tokenCategory == category, 'Invalid token category');

      /*
        Verify that the app instance is authorized:
        terminalHash now binds the Paytaca app's ID + pubkey of the wallet as the authorized 'terminal'
      */
      bytes fullHash = sha256(terminalId + terminalPk);
      bytes terminalHash = fullHash.split(20)[0];

      /*
        Break down the NFT commitment into fields:
        stores the commitment of the first input to commitment;
        splits commitment into 2 parts: first byte (flag) - payment enabled?, the rest of the byte - commitment data;
        splits rest into 2 parts: first 4 bytes stored in expirationBlock
        the rest of the byte is stored in rest2;
        splits rest2 into two parts: first 8 bytes stored in spendLimit
        the rest of the byte is stored in expectedTerminalHash
       */ 
      bytes commitment = tx.inputs[0].nftCommitment;

      // Commitment decoding and validation
      // [flag (1)] + expirationBlock (4) + spendLimit (4) + BCV (11) + expectedTerminalHash (20)

      // splits commitment into 2 parts: first byte (flag) // flag 0x01 means payment enabled / authorized
      bytes flag, bytes rest = commitment.split(1); 
      
      // splits rest into 2 parts: first 4 bytes stored in expirationBlock
      bytes expirationBlock, bytes rest2 = rest.split(4);

      // splits rest2 into two parts: first 8 bytes stored in spendLimit
      bytes spendLimit, bytes rest3 = rest2.split(4);

      // splits rest3 into two parts: first 16 bytes stored in bcv
      bytes receivedBCV, bytes expectedTerminalHash = rest3.split(11);

      // The BCV received in the NFT must match the contract's state BCV
      require(receivedBCV == currentBCV, 'Access denied: Invalid BCV');

      require(flag == 0x01, 'Access denied: Terminal is not authorized');
      // Only continue if the terminal hash matches what the contract expects
      require(terminalHash == expectedTerminalHash, 'Access denied: Invalid app/terminal id');
      require(tx.locktime <= int(expirationBlock), 'Authentication has expired');

      /*
        Ensure NFT commitment cannot be tampered with.
        It must stay exactly the same after the transaction.
        require that auth NFT commitment is not tampered with after spending
      */
      require(commitment != tx.outputs[0].nftCommitment, 'Auth NFT commitment should change (new BCV required)');

      /*
        Auth NFT must always return back to this contract (self-locking):
        retrieves the locking script or bytecode of the input the contract is currently spending
        it takes the contract's own code and conditions that locked the funds being spent now
      */
      bytes contractLock = tx.inputs[this.activeInputIndex].lockingBytecode;

      /*
        if the locking script of output 0 is equal to the contract's locking script, result is true
        meaning NFTs are being sent back to contract
      */
      bool nftSendsToContract = tx.outputs[0].lockingBytecode == contractLock;
      require(nftSendsToContract, 'Auth NFT must return to contract');

      /*
        Output[1] must send funds to the Paytaca app’s public key.
        - ensures the "recipient" is really the app acting as terminal.
        creates a lock, and insert terminalPk to the locking script or
        creates a lock that only the authorized terminalPk can open
      */
      bytes25 recipientLock = new LockingBytecodeP2PKH(hash160(terminalPk));
      bool sendsToRecipient = tx.outputs[1].lockingBytecode == recipientLock;
      require(sendsToRecipient, 'Send amount must be sent to the recipient');

      // Enforce spend limit
      int actualSendAmount = tx.outputs[1].value;
      require(actualSendAmount <= int(spendLimit), 'Send amount exceeds spend limit');

      // If a third output exists, it must return change back to this contract
      if (tx.outputs.length == 3) {
          require(tx.outputs[2].lockingBytecode == contractLock, 'Change must return to contract');
      }
    }

    /*
      Owner can "sweep" — withdraw everything locked in this contract.
    */
    function sweep(pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');
    }

    /*
      Owner can "mutate" — update contract rules or migrate state.  
    */
    function mutate(pubkey ownerPk, sig ownerSig, sig terminalSig, bytes newContractLockingBytecode) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');
    }
}

  
  

    

