pragma cashscript ^0.11.0;

contract TapToPay(
  bytes20 ownerPkh, 
  bytes20 backendPkh, 
  bytes category
  ) {

    /** terminalId and terminalPk now refer to POS app */
    function spend(
      bytes terminalId,
      sig terminalSig, 
      pubkey terminalPk, 
      sig backendSig, 
      pubkey backendPk 
    ){
      // 11 bytes reserved for BCV
      int BCV_SIZE = 11;

      // --- Signature verifications ---
      require(hash160(backendPk) == backendPkh, 'Invalid backend public key hash');
      require(checkSig(backendSig, backendPk), 'Invalid backend signature');
      require(checkSig(terminalSig, terminalPk), 'Invalid app (terminal) signature');

      // must have min 2 and max 3 outputs only
       require(tx.outputs.length >= 2 && tx.outputs.length <= 3, 'Unexpected number of outputs');
      
      /*
        Auth NFT presented must have correct category
        Take the first 32 bytes (base tokenID) of the token category from the first input and save it as tokenCategory.
        Specified 32 bytes just in case it's longer (e.g. 64 bytes) - the rest of the bytes may just be commitment data
      */
      bytes tokenCategory = (tx.inputs[0].tokenCategory).split(32)[0];
      require(tokenCategory == category, 'Invalid token category');

      // Compute Terminal Hash
      bytes fullHash = sha256(terminalId + terminalPk);
      bytes terminalHash = fullHash.split(20)[0];

      // Stores the commitment of the first input (Auth NFT)
      bytes commitment = tx.inputs[0].nftCommitment;

      // Commitment decoding and validation
      // Structure: [flag (1)] + expirationBlock (4) + spendLimit (4) + BCV (11) + expectedTerminalHash (20)

      // splits commitment into 2 parts: first byte (flag) // flag 0x01 means payment enabled / authorized
      bytes flag, bytes rest = commitment.split(1); 
      
      // splits rest into 2 parts: first 4 bytes stored in expirationBlock
      bytes expirationBlock, bytes rest2 = rest.split(4);

      // splits rest2 into two parts: first 8 bytes stored in spendLimit
      bytes spendLimit, bytes rest3 = rest2.split(4);

      // splits rest3 into two parts: first 16 bytes stored in bcv
      bytes receivedBCV, bytes expectedTerminalHash = rest3.split(BCV_SIZE);

      // Remaining Authorization Checks
      require(flag == 0x01, 'Access denied: Terminal is not authorized');
      require(terminalHash == expectedTerminalHash, 'Access denied: Invalid app/terminal id');
      require(tx.locktime <= int(expirationBlock), 'Authentication has expired');

      // Covenant Output Enforcement
      // The Auth NFT must return to the contract, and must contain the NEW BCV
      require(commitment != tx.outputs[0].nftCommitment, 'Auth NFT commitment should change (new BCV required)');

      
      // NEW BCV gets encoded into the NFT's commitment. Extract the new BCV
      bytes outputCommitment = tx.outputs[0].nftCommitment;
      bytes newFlag, bytes newRest = outputCommitment.split(1);
      bytes newExpirationBlock, bytes newRest2 = newRest.split(4);
      bytes newSpendLimit, bytes newRest3 = newRest2.split(4);
      bytes newBCV, bytes newExpectedTerminalHash = newRest3.split(BCV_SIZE);

      // Output[0] must go back to contract
      bytes contractLock = tx.inputs[this.activeInputIndex].lockingBytecode;
      // Auth NFT must go back to the contract
      bool nftSendsToContract = tx.outputs[0].lockingBytecode == contractLock;
      require(nftSendsToContract, 'Auth NFT must send back to this contract.');

      /*
        Output[1] must send funds to the Paytaca app’s public key.
        - ensures the "recipient" is really the app acting as terminal.
        creates a lock, and insert terminalPk to the locking script or
        creates a lock that only the authorized terminalPk can open
      */

      // Check Output[1] (Payment)
      bytes25 recipientLock = new LockingBytecodeP2PKH(hash160(terminalPk));
      bool sendsToRecipient = tx.outputs[1].lockingBytecode == recipientLock;
      require(sendsToRecipient, 'Send amount must be sent to the recipient');

      // Enforce spend limit
      int actualSendAmount = tx.outputs[1].value;
      require(actualSendAmount <= int(spendLimit), 'Send amount exceeds spend limit');

      // Check for change, they must go back to the contract
      if (tx.outputs.length == 3) {
          require(tx.outputs[2].lockingBytecode == contractLock, 'Change must return to contract.');
      }
    }

    /*
      Owner can "sweep" — withdraw everything locked in this contract.
    */
    function sweep(pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');
    }

    /*
      Owner can "mutate" — update contract rules or migrate state.  
    */
    function mutate(pubkey ownerPk, sig ownerSig, sig terminalSig, bytes newContractLockingBytecode) {
        require(hash160(ownerPk) == ownerPkh, 'Invalid owner public key hash');
        require(checkSig(ownerSig, ownerPk), 'Invalid owner signature');

        // The funds must be sent back to a new locking script that has the new BCV - done in JS
    }
  }

  
  

    

