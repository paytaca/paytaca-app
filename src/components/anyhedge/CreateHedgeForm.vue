<template>
  <q-form @submit="createHedgePosition()" class="q-gutter-y-md" ref="form" @validation-error="alertError">
    <q-banner v-if="errors.length > 0" dense rounded class="text-white bg-red q-my-sm">
      <ul class="q-pl-md">
        <li v-for="(error, index) in errors" :key="index">
          {{ error }}
        </li>
      </ul>
    </q-banner>

    <div v-if="createHedgeForm.selectedAsset?.latestPrice?.priceValue">
      Current price:
      {{ createHedgeForm.selectedAsset.latestPrice.priceValue / 10 ** (createHedgeForm.selectedAsset.assetDecimals || 0) }}
      <template v-if="createHedgeForm.selectedAsset?.assetCurrency">
        {{ createHedgeForm.selectedAsset.assetCurrency }} / BCH
      </template>
    </div>
    <div class="row no-wrap q-gutter-x-sm">
      <q-input
        :dark="darkMode"
        outlined
        dense
        label="Amount"
        suffix="BCH"
        :disable="loading"
        v-model="createHedgeForm.amount"
        reactive-rules
        :rules="[
          val => val > 0 || 'Invalid amount',
          val => val >= createHedgeFormConstraints.minimumAmount || `Liquidity requires atleast ${createHedgeFormConstraints.minimumAmount} BCH`,
          val => val <= createHedgeFormConstraints.maximumAmount || `Liquidity requires at most ${createHedgeFormConstraints.maximumAmount} BCH`,
        ]"
        class="q-space"
      >
        <template v-slot:hint>
          <div v-if="createHedgeFormMetadata.nominalAmount" class="text-caption text-grey">
            {{ createHedgeFormMetadata.nominalAmount }} {{ createHedgeForm.selectedAsset?.assetCurrency }}
          </div>
        </template>
      </q-input>
      <q-select
        :dark="darkMode"
        outlined
        dense
        label="Asset"
        :options="oracles"
        map-options
        option-value="oraclePubkey"
        option-label="assetName"
        :disable="loading"
        v-model="createHedgeForm.selectedAsset"
        :popup-content-class="darkMode ? '': 'text-black'"
        reactive-rules
        :rules="[
          val => Boolean(!createHedgeForm.autoMatch || createHedgeForm.autoMatchPoolTarget !== 'anyhedge_LP' || val?.oraclePubkey ) || 'Required'
        ]"
      />
    </div>
    <DurationField
      :dark="darkMode"
      outlined
      dense
      label="Duration"
      v-model="createHedgeForm.duration"
      :disable="loading"
      reactive-rules
      :rules="[
        val => val >= 0 || 'Invalid duration',
        (val, units) => val >= createHedgeFormConstraints.minimumDuration || `Must atleast be ${createHedgeFormConstraints.minimumDuration/ units.value} ${units.label}`,
        (val, units) => val <= createHedgeFormConstraints.maximumDuration || `Must at most be ${createHedgeFormConstraints.maximumAmount/ units.value} ${units.label}`,
      ]"
    />
    <div class="row no-wrap q-gutter-x-sm">
      <q-input
        :dark="darkMode"
        outlined
        dense
        label="Low"
        suffix="%"
        :disable="loading"
        v-model="createHedgeForm.lowLiquidationMultiplierPctg"
        reactive-rules
        :rules="[
          val => (val > 0 && val < 100) || 'Invalid',
          val => val/100 >= createHedgeFormConstraints.minimumLiquidationLimit || `Must atleast be ${createHedgeFormConstraints.minimumLiquidationLimit * 100} %`,
          val => val/100 <= createHedgeFormConstraints.maximumLiquidationLimit || `Must at most be ${createHedgeFormConstraints.maximumLiquidationLimit * 100} %`,
        ]"
      >
        <template v-slot:hint>
          <div v-if="createHedgeFormMetadata.lowLiquidationPrice" class="text-caption text-grey">
            {{ createHedgeFormMetadata.lowLiquidationPrice }} {{ createHedgeForm.selectedAsset?.assetCurrency }} / BCH
          </div>
        </template>
      </q-input>
      <q-input
        :dark="darkMode"
        outlined
        dense
        label="High"
        suffix="%"
        :disable="loading"
        v-model="createHedgeForm.highLiquidationMultiplierPctg"
        :rules="[
          val => (val > 100) || 'Invalid'
        ]"
      >
        <template v-slot:hint>
          <div v-if="createHedgeFormMetadata.highLiquidationPrice" class="text-caption text-grey">
            {{ createHedgeFormMetadata.highLiquidationPrice }} {{ createHedgeForm.selectedAsset?.assetCurrency }} / BCH
          </div>
        </template>
      </q-input>
    </div>

    <div class="row q-gutter-x-md items-center">
      <q-toggle
        :dark="darkMode"
        label="Match to liquidity pool"
        :disable="loading"
        v-model="createHedgeForm.autoMatch"
      />
      <q-icon
        :color="darkMode ? 'grey-7' : 'black'"
        size="sm"
        name="help"
      >
        <q-popup-proxy :breakpoint="0">
          <div :class="['q-px-md q-py-sm', darkMode ? 'pt-dark-label pt-dark' : 'text-black']" class="text-caption">
            Disabling will create a hedge position offer instead
          </div>
        </q-popup-proxy>
      </q-icon>
    </div>
    <q-slide-transition>
      <div v-if="createHedgeForm.autoMatch">
        <div :class="darkMode ? 'text-white' : 'text-grey-7'">Liquidity Pool</div>
        <q-btn-toggle
          :dark="darkMode"
          no-caps
          label="Liquidity Pool"
          :disable="loading"
          v-model="createHedgeForm.autoMatchPoolTarget"
          :options="[
            {label: 'General Protocol LP', value: 'anyhedge_LP'},
            {label: 'Paytaca (P2P)', value: 'watchtower_P2P', disable: true },
          ]"
        />
      </div>
    </q-slide-transition>

    <div class="q-gutter-y-md">
      <div v-if="loading" class="text-center">
        {{ loadingMsg }}
      </div>
      <q-btn
        no-caps
        :loading="loading"
        :disable="loading"
        label="Create"
        type="submit"
        color="brandblue"
        class="full-width"
      />
      <q-btn
        no-caps
        outline
        :loading="loading"
        :disable="loading"
        label="Cancel"
        color="grey"
        class="full-width"
        @click="$emit('cancel')"
      />

    </div>
  </q-form>
</template>
<script setup>
import { parseHedgePositionData } from '../../wallet/anyhedge/formatters'
import { calculateGeneralProtocolsLPFee, createFundingProposal } from '../../wallet/anyhedge/funding'
import { Wallet } from 'src/wallet';
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue'
import { useStore } from 'vuex'
import DurationField from './DurationField.vue';
import { anyhedgeBackend } from 'src/wallet/anyhedge/backend';

function alertError(...args) {
  console.error('form error', args)
}

// misc
const $store = useStore()
const darkMode = computed(() => $store.getters['darkmode/getStatus'])

const $emit = defineEmits(['created', 'cancel'])

const props = defineProps({
  wallet: Wallet,
})

const oracles = computed(() => {
  const oracles = $store.getters['anyhedge/oracles']
  const parsedOracles = Object.getOwnPropertyNames(oracles)
    .map(oraclePubkey => {
      if (!oracles?.[oraclePubkey]) return
      
      return Object.assign({ oraclePubkey }, oracles[oraclePubkey])
    })
    .filter(Boolean)
    .filter(oracle => oracle?.oraclePubkey)
    parsedOracles.unshift({
      oraclePubkey: '',
      assetName: 'Auto',
    })

    return parsedOracles
})

const createHedgeForm = ref({
  amount: 0.0,
  duration: 4 * 3600,
  lowLiquidationMultiplierPctg: 0.8 * 100,
  highLiquidationMultiplierPctg: 10 * 100,
  selectedAsset: oracles.value[0],

  autoMatch: true,
  autoMatchPoolTarget: 'anyhedge_LP',
})
const createHedgeFormMetadata = computed(() => {
  const data = { nominalAmount: 0, longNominalAmount: 0, lowLiquidationPrice: 0, highLiquidationPrice: 0 }

  // const priceValue = 13049
  const priceValue = createHedgeForm.value?.selectedAsset?.latestPrice?.priceValue
  const decimalsMultiplier = 10 ** createHedgeForm.value?.selectedAsset?.assetDecimals
  const assetPrice = priceValue / decimalsMultiplier

  if (assetPrice) {
    data.nominalAmount = Math.round(priceValue * createHedgeForm.value.amount) / decimalsMultiplier
    data.lowLiquidationPrice = Math.round(assetPrice * createHedgeForm.value.lowLiquidationMultiplierPctg) / 100
    data.highLiquidationPrice = Math.round(assetPrice * createHedgeForm.value.highLiquidationMultiplierPctg) / 100
    
    const totalBch = data.nominalAmount / data.lowLiquidationPrice
    const longBch = totalBch - createHedgeForm.value.amount
    const longNominalUnits = Math.round(longBch * priceValue) / decimalsMultiplier

    // const totalNominalAmountMult = 100 / createHedgeForm.value.lowLiquidationMultiplierPctg
    // const totalNominalAmount = data.nominalAmount * totalNominalAmountMult
    data.couterPartyNominalAmount = longNominalUnits
  }

  return data
})

const form = ref(null)
async function clearCreateHedgeForm() {
  createHedgeForm.value.amount = 0
  createHedgeForm.value.duration = 0
  createHedgeForm.value.lowLiquidationMultiplierPctg = 0.8 * 100
  createHedgeForm.value.highLiquidationMultiplierPctg = 10 * 100
  createHedgeForm.value.selectedAsset = oracles.value[0]
  createHedgeForm.value.autoMatch = true
  createHedgeForm.value.autoMatchPoolTarget = 'anyhedge_LP'

  await nextTick()
  form.value.resetValidation()
}

const liquidityServiceInfo = computed(() => $store.getters['anyhedge/liquidityServiceInfo'])
const createHedgeFormConstraints = computed(() => {
  const data = {
    minimumNominalUnits: 0,
    maximumNominalUnits: Infinity,
    minimumDuration: 0,
    maximumDuration: Infinity,
    minimumLiquidationLimit: 0,
    maximumLiquidationLimit: Infinity,
    minimumAmount: 0,
    maximumAmount: Infinity,
  }

  const { autoMatch, autoMatchPoolTarget, selectedAsset } = createHedgeForm.value
  if (autoMatch && autoMatchPoolTarget === 'anyhedge_LP' && selectedAsset) {
    const constraints = liquidityServiceInfo.value?.liquidityParameters?.[selectedAsset?.oraclePubkey]?.hedge
    if (constraints) Object.assign(data, constraints)

    const priceValue = selectedAsset?.latestPrice?.priceValue
    if (priceValue) {
      data.minimumAmount = Math.round(data.minimumNominalUnits * 10**8 / priceValue) / 10 ** 8
      data.maximumAmount = Math.round(data.maximumNominalUnits * 10**8 / priceValue) / 10 ** 8
    }
  }

  return data
})

const loading = ref(false)
const loadingMsg = ref('')
const errors = ref([])

async function getAddressesFromStore() {
  const response = { success: false, addressSet: { change: '', receiving: '', pubkey: '', index: 0, privateKey: '' } }
  try {
    const bchWalletInfo = $store.getters['global/getWallet']('bch')
    if (bchWalletInfo) {
      const { lastAddress, lastChangeAddress, lastAddressIndex } = bchWalletInfo
      if (lastAddress && lastChangeAddress && lastAddressIndex >= 0 ) {
        response.addressSet.receiving = lastAddress
        response.addressSet.change = lastChangeAddress
        response.addressSet.pubkey = await props.wallet.BCH.getPublicKey(`0/${lastAddressIndex}`)
        response.addressSet.index = lastAddressIndex
        response.addressSet.privateKey = await props.wallet.BCH.getPrivateKey(`0/${lastAddressIndex}`)
        response.success = true
      }
    }
  } catch(error) {
    console.error(error)
  }

  return response
}
onMounted(() => window.a = getAddressesFromStore)

async function getAddresses() {
  const response = { success: false, error: null, addressSet: { change: '', receiving: '', pubkey: '', index: 0, privateKey: ''} }
  try {
    loadingMsg.value = 'Generating receiving address'
    loading.value = true

    const getAddressesFromStoreResponse = await getAddressesFromStore()
    if (getAddressesFromStoreResponse.success) {
      response.addressSet = getAddressesFromStoreResponse.addressSet
      response.success = true
      return response
    }

    const addressIndex = 0
    let addressSet = await props.wallet.BCH.getNewAddressSet(addressIndex)
    if (!addressSet?.receiving) throw new Error('Expected receiving address')
    response.addressSet = addressSet
    response.addressSet.index = addressIndex
    response.addressSet.privateKey = await props.wallet.BCH.getPrivateKey(`0/${addressIndex}`)
    response.addressSet.pubkey = await props.wallet.BCH.getPublicKey(`0/${addressIndex}`)
    response.success = true
    return response
  } catch(error) {
    errors.value = ['Error generating addresses']
    response.error = error
    response.success = false
    return response
  } finally {
    loadingMsg.value = ''
    loading.value = false
  }
}

async function createHedgePosition() {
  console.log('creating hedge position')
  // retrieve addresses
  const getAddressesResponse = await getAddresses()
  if (!getAddressesResponse?.success) return
  const { addressSet } = getAddressesResponse

  // return console.log(getAddressesResponse)

  // grouping data
  const intent = {
    amount: createHedgeForm.value.amount,
    lowPriceMult: createHedgeForm.value.lowLiquidationMultiplierPctg / 100,
    highPriceMult: createHedgeForm.value.highLiquidationMultiplierPctg / 100,
    duration: createHedgeForm.value.duration,
  }
  const pubkeys = { hedgeAddress: addressSet.receiving, hedgePubkey: addressSet.pubkey }
  const misc = {
    walletHash: props.wallet.BCH.getWalletHash(),
    autoMatch: createHedgeForm.value.autoMatch,
    autoMatchPoolTarget: createHedgeForm.value.autoMatchPoolTarget,
    // necessary when using settlement service, they serve as credentials to gain access to the contract
    accessKeys: { publicKey: '', signature: '' },
  }

  const priceData = { oraclePubkey: '', priceValue: 0, messageTimestamp: 0, messageSequence: 0 }
  if (createHedgeForm.value.selectedAsset?.oraclePubkey) {
    priceData.oraclePubkey = createHedgeForm.value.selectedAsset.oraclePubkey
    priceData.priceValue = createHedgeForm.value.selectedAsset?.latestPrice?.priceValue
    priceData.messageTimestamp = createHedgeForm.value.selectedAsset?.latestPrice?.messageTimestamp
    priceData.messageSequence = createHedgeForm.value.selectedAsset?.latestPrice?.messageSequence
  }

  const funding = {
    prepareFunding: false,
    liquidityFee: 0,
    fee: { satoshis: 0, address: '' },
    fundingProposal: {
      txHash: '',
      txIndex: 0,
      txValue: 0,
      scriptSig: '',
      pubkey: '',
      inputTxHashes: [],
    },
    contractData: {},
  }

  // calculating fees
  if (misc.autoMatchPoolTarget === 'anyhedge_LP') {
    try {
      loading.value = true
      loadingMsg.value = 'Calculating contract fees'
      const generalProtocolsLPFeeResponse = await calculateGeneralProtocolsLPFee(intent, pubkeys, priceData, liquidityServiceInfo.value, addressSet.privateKey)
      if(!generalProtocolsLPFeeResponse?.success) throw generalProtocolsLPFeeResponse

      misc.accessKeys.publicKey = generalProtocolsLPFeeResponse.accessKeys.publicKey
      misc.accessKeys.signature = generalProtocolsLPFeeResponse.accessKeys.signature
      pubkeys.longAddress = generalProtocolsLPFeeResponse.contractData.metadata.longAddress
      pubkeys.longPubkey = generalProtocolsLPFeeResponse.contractData.metadata.longPublicKey
      if (generalProtocolsLPFeeResponse.contractData?.fee?.satoshis) {
        funding.fee.satoshis = generalProtocolsLPFeeResponse.contractData.fee.satoshis
        funding.fee.address = generalProtocolsLPFeeResponse.contractData.fee.address
      }

      if (generalProtocolsLPFeeResponse?.liquidityFee?.fee) {
        funding.liquidityFee = generalProtocolsLPFeeResponse.liquidityFee.fee
      }
      funding.prepareFunding = true
    } catch(error) {
      console.error(error)
      errors.value = [ typeof error?.error === 'string' ? error.error: 'Error calculating contract fees' ]
      return
    } finally {
      loading.value = false
      loadingMsg.value = ''
    }
  } else if (misc.autoMatchPoolTarget === 'watchtower_P2P') {
    funding.prepareFunding = false
    funding.fee.satoshis = 0
    funding.fee.address = ''
  }

  // creating utxo phase
  if (funding.prepareFunding) {
    try {
      // the following data possibly doesn't exist but;
      // is necessary for creating a funding utxo
      if (!pubkeys.longAddress || !pubkeys.longPubkey ||
        !priceData.oraclePubkey || !priceData.priceValue || !priceData.messageTimestamp || !priceData.messageSequence
      ) {
        errors.value = ['Unable to create funding utxo due to incomplete data']
        return
      }

      loading.value = true
      loadingMsg.value = 'Creating utxo for funding proposal'
      const contractData = await parseHedgePositionData({
        satoshis: intent.amount * 10 ** 8,
        start_timestamp: priceData.messageTimestamp,
        maturity_timestamp: priceData.messageTimestamp + intent.duration,
        hedge_address: pubkeys.hedgeAddress,
        hedge_pubkey: pubkeys.hedgePubkey,
        long_address: pubkeys.longAddress,
        long_pubkey: pubkeys.longPubkey,
        oracle_pubkey: priceData.oraclePubkey,
        start_price: priceData.priceValue,
        low_liquidation_multiplier: intent.lowPriceMult,
        high_liquidation_multiplier: intent.highPriceMult,
      })

      if (!contractData.fee) contractData.fee = {}
      contractData.fee.satoshis = funding.fee.satoshis
      contractData.fee.address = funding.fee.address
      const { fundingUtxo, signedFundingProposal } = await createFundingProposal(
        contractData, "hedge", props.wallet, addressSet, funding.liquidityFee)
      funding.fundingProposal.txHash = fundingUtxo.txid
      funding.fundingProposal.txIndex = fundingUtxo.vout
      funding.fundingProposal.txValue = fundingUtxo.amount
      funding.fundingProposal.inputTxHashes = fundingUtxo.dependencyTxids
      funding.fundingProposal.pubkey = signedFundingProposal.publicKey
      funding.fundingProposal.scriptSig = signedFundingProposal.signature
      funding.contractData = contractData
    } catch(error) {
      console.error(error)
      errors.value = ['Encountered error in preparing funding transaction']
      return

    } finally {
      loading.value = false
      loadingMsg.value = ''
    }
  }

  const hedgePositionOfferData = {
    wallet_hash: misc.walletHash,

    satoshis: intent.amount * 10 ** 8,
    duration_seconds: intent.duration,
    high_liquidation_multiplier: intent.highPriceMult,
    low_liquidation_multiplier: intent.lowPriceMult,

    hedge_address: pubkeys.hedgeAddress,
    hedge_pubkey: pubkeys.hedgePubkey,

    oracle_pubkey: priceData.oraclePubkey || undefined,
    price_oracle_message_sequence: priceData.messageSequence || undefined,

    auto_match: misc.autoMatch,
    auto_match_pool_target: misc.autoMatchPoolTarget,
    save_position_offer: !misc.autoMatch,
  }

  const fungGPLPContractData = {
    contract_address: funding.contractData.address,
    hedge_wallet_hash: misc.walletHash,
    hedge_pubkey: misc.accessKeys.publicKey,
    oracle_message_sequence: priceData.messageSequence || undefined,
    settlement_service: {
      domain: liquidityServiceInfo.value?.settlementService?.host,
      scheme: liquidityServiceInfo.value?.settlementService?.scheme,
      port: liquidityServiceInfo.value?.settlementService?.port,
      hedge_signature: misc.accessKeys.signature,
    },
    funding_proposal: {
      tx_hash: funding.fundingProposal.txHash,
      tx_index: funding.fundingProposal.txIndex,
      tx_value: funding.fundingProposal.txValue,
      script_sig: funding.fundingProposal.scriptSig,
      pubkey: funding.fundingProposal.pubkey,
      input_tx_hashes: funding.fundingProposal.inputTxHashes
    }
  }

  console.log(hedgePositionOfferData)
  console.log(fungGPLPContractData)
  // return

  let data
  let path = ''
  let isResponseOffer = true
  if (misc.autoMatch && misc.autoMatchPoolTarget === 'anyhedge_LP') {
    data = fungGPLPContractData
    path = '/anyhedge/hedge-positions/fund_gp_lp_contract/'
    isResponseOffer = false
  } else {
    data = hedgePositionOfferData
    path = '/anyhedge/hedge-position-offers/'
    isResponseOffer = true
  }

  loading.value = true
  loadingMsg.value = isResponseOffer ? 'Creating hedge position offer' : 'Finalizing hedge position'

  anyhedgeBackend.post(path, data)  
    .then(response => {
      console.log(response)
      if(response?.data?.id || response?.data?.hedge_position?.id) {
        const emitData = {}
        if (isResponseOffer) emitData.hedgePositionOffer = response.data
        else emitData.hedgePosition = response.data
        $emit('created', emitData)
        clearCreateHedgeForm()
        errors.value = []
        return Promise.resolve(response)
      }
      return Promise.reject(response)
    })
    .catch(error => {
      console.log(error)
      errors.value = [
        isResponseOffer ? 'Encountered error in creating hedge position offer' : 'Encountered error in creating hedge position'
      ]
    })
    .finally(() => {
      loading.value = false
      loadingMsg.value = ''
    })
}

// mechanisms to keep selected asset prices up to date
const oraclePriceUpdateInterval = ref(null)
onMounted(() => {
  clearInterval(oraclePriceUpdateInterval.value)
  oraclePriceUpdateInterval.value = setInterval(() => updateSelectedAssetPrice(), 60 * 1000)
})
onUnmounted(() => clearInterval(oraclePriceUpdateInterval.value))
watch(() => createHedgeForm.value?.selectedAsset?.oraclePubkey, () => updateSelectedAssetPrice())
function updateSelectedAssetPrice() {
  if (!createHedgeForm.value?.selectedAsset?.oraclePubkey) return
  const dispatchPayload = { oraclePubkey: createHedgeForm.value?.selectedAsset?.oraclePubkey, checkTimestampAge: true }
  $store.dispatch('anyhedge/updateOracleLatestPrice', dispatchPayload)
}
</script>
